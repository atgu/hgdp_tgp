cor.mat <- reshape2::dcast(cor.ds, Var1~Var2, value.var='V3')
# set first column values (population names) as row names
rownames(cor.mat) <- cor.mat[,1]
# remove the first column and convert the correlation data frame into a matrix
cor.mat <- as.matrix(cor.mat[-1])
# read-in metadata from gnomAD and select only the desired columns
hgdp_tgp_unfil <- read.delim('~/Desktop/Broad/alicia/HGDP_TGP/hgdp_tgp/gnomad_meta_v1.tsv', header=T, sep='\t') %>% select(s, project_meta.title, starts_with('hgdp_tgp_meta'))
# some sample IDs have 'v3.1::' prefix as done in gnomAD so stripping that in order to match correctly with the pc score files
hgdp_tgp_unfil$s <- gsub('v3.1::', '', hgdp_tgp_unfil$s)
# set up df for annotation
# since FST is population level, the annotation file doesn't need to be subsetted
hgdp_tgp <- unique(hgdp_tgp_unfil[c("hgdp_tgp_meta.Population", "hgdp_tgp_meta.Genetic.region")]) # select only population and region columns
rownames(hgdp_tgp) <- hgdp_tgp[,1] # set populations as rownames
hgdp_tgp <- hgdp_tgp[-1] # remove the population column
colnames(hgdp_tgp) <- c("Region") # rename column
### set color for heat map annotation - obtain from metadata itself for consistency across all plots
# region
reg_colr_df <- unique(hgdp_tgp_unfil[c("hgdp_tgp_meta.Genetic.region", "hgdp_tgp_meta.Continent.colors")])
reg_colr <- reg_colr_df %>% pull(hgdp_tgp_meta.Continent.colors, hgdp_tgp_meta.Genetic.region)
annot_reg_colr <- list(Region = reg_colr) # convert into a list
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
rnames <- rownames(cor.mat)
hc <-  hclust(dist(cor.mat))
cor.mat2 <- cor.mat[hc$order, hc$order]
cor.mat2[lower.tri(cor.mat2)] <- NA
cor.mat2 <- cor.mat2[rnames, rnames]
# replot just the upper triangle of the heatmap without reordering the clutser
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as png
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.png', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as pdf
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.pdf', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
rnames <- rownames(cor.mat)
hc <-  hclust(dist(cor.mat))
cor.mat2 <- cor.mat[hc$order, hc$order]
cor.mat2[upper.tri(cor.mat2)] <- NA
cor.mat2 <- cor.mat2[rnames, rnames]
# replot just the upper triangle of the heatmap without reordering the clutser
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as png
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.png', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as pdf
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.pdf', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
rnames <- rownames(cor.mat)
hc <-  hclust(dist(cor.mat))
cor.mat2 <- cor.mat[hc$order, hc$order]
cor.mat2[upper.tri(cor.mat2)] <- NA
cor.mat2 <- cor.mat2[rnames, rnames]
# replot just the upper triangle of the heatmap without reordering the clutser
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as png
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.png', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as pdf
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.pdf', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
rnames <- rownames(cor.mat)
hc <-  hclust(dist(cor.mat))
cor.mat2 <- cor.mat[hc$order, hc$order]
cor.mat2[lower.tri(cor.mat2)] <- NA
cor.mat2 <- cor.mat2[rnames, rnames]
# replot just the upper triangle of the heatmap without reordering the clutser
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as png
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.png', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as pdf
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.pdf', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
rnames <- rownames(cor.mat)
hc <-  hclust(dist(cor.mat))
cor.mat2 <- cor.mat[hc$order, hc$order]
cor.mat2[upper.tri(cor.mat2)] <- NA
cor.mat2 <- cor.mat2[rnames, rnames]
# replot just the upper triangle of the heatmap without reordering the clutser
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as png
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.png', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as pdf
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.pdf', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
?pheatmap
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
rnames <- rownames(cor.mat)
hc <-  hclust(dist(cor.mat))
cor.mat2 <- cor.mat[hc$order, hc$order]
cor.mat2[upper.tri(cor.mat2)] <- NA
cor.mat2 <- cor.mat2[rnames, rnames]
# replot just the upper triangle of the heatmap without reordering the clutser
p <- pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
draw(p, annotation_legend_side = "left")
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
rnames <- rownames(cor.mat)
hc <-  hclust(dist(cor.mat))
cor.mat2 <- cor.mat[hc$order, hc$order]
cor.mat2[upper.tri(cor.mat2)] <- NA
cor.mat2 <- cor.mat2[rnames, rnames]
# replot just the upper triangle of the heatmap without reordering the clutser
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as png
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.png', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as pdf
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.pdf', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_row = hgdp_tgp, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_rownames = F, treeheight_row=0)
# replot just the upper triangle of the heatmap without reordering the clutser
pheatmap(cor.mat2, cluster_row = hc, cluster_col = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_rownames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_row = hc, cluster_col = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_rownames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_rownames = F, treeheight_row=0)
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc)
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr)
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp)
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA)
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr)
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA)
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"))
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white")
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_rownames = F)
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white")
pheatmap(cor.mat2, cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_rownames = F, treeheight_col=0)
# read-in file with fst values
ds <- read.table('~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/mean_fst.txt')
# get population labels - 78 populations
vars <- unique(c(ds$V1, ds$V2))
# create all possible pairs including reverse pairs and pairs between same population labels
# 3003 (original pairs) + 3003 (pairs reversed) + 78 (pairs between the same popn) = 6084 pairs in total
cor.ds <- expand.grid(vars, vars)
# add the fst value for each pair
# for pairs between same populations, set fst value to 0
cor.ds <- rbind(merge(cor.ds, ds, by.x=c('Var1', 'Var2'), by.y=c('V1', 'V2')),
merge(cor.ds, ds, by.x=c('Var2', 'Var1'), by.y=c('V1', 'V2')),
data.frame(Var1=vars, Var2=vars, V3=0))
# convert table to a correlation data frame (same population pairs on the diagonal)
cor.mat <- reshape2::dcast(cor.ds, Var1~Var2, value.var='V3')
# set first column values (population names) as row names
rownames(cor.mat) <- cor.mat[,1]
# remove the first column and convert the correlation data frame into a matrix
cor.mat <- as.matrix(cor.mat[-1])
# read-in metadata from gnomAD and select only the desired columns
hgdp_tgp_unfil <- read.delim('~/Desktop/Broad/alicia/HGDP_TGP/hgdp_tgp/gnomad_meta_v1.tsv', header=T, sep='\t') %>% select(s, project_meta.title, starts_with('hgdp_tgp_meta'))
# some sample IDs have 'v3.1::' prefix as done in gnomAD so stripping that in order to match correctly with the pc score files
hgdp_tgp_unfil$s <- gsub('v3.1::', '', hgdp_tgp_unfil$s)
# set up df for annotation
# since FST is population level, the annotation file doesn't need to be subsetted
hgdp_tgp <- unique(hgdp_tgp_unfil[c("hgdp_tgp_meta.Population", "hgdp_tgp_meta.Genetic.region")]) # select only population and region columns
rownames(hgdp_tgp) <- hgdp_tgp[,1] # set populations as rownames
hgdp_tgp <- hgdp_tgp[-1] # remove the population column
colnames(hgdp_tgp) <- c("Region") # rename column
### set color for heat map annotation - obtain from metadata itself for consistency across all plots
# region
reg_colr_df <- unique(hgdp_tgp_unfil[c("hgdp_tgp_meta.Genetic.region", "hgdp_tgp_meta.Continent.colors")])
reg_colr <- reg_colr_df %>% pull(hgdp_tgp_meta.Continent.colors, hgdp_tgp_meta.Genetic.region)
annot_reg_colr <- list(Region = reg_colr) # convert into a list
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
rnames <- rownames(cor.mat)
hc <-  hclust(dist(cor.mat))
cor.mat2 <- cor.mat[hc$order, hc$order]
cor.mat2[upper.tri(cor.mat2)] <- NA
cor.mat2 <- cor.mat2[rnames, rnames]
# replot just the upper triangle of the heatmap without reordering the clutser
pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_lowertri.png', cluster_rows = hc, cluster_cols = hc, annotation_row = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_rownames = F, treeheight_col=0)
#pheatmap(cor.mat2, cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as png
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.png', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# save as pdf
#pheatmap(cor.mat2, filename='~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.pdf', cluster_col = hc, cluster_row = hc, annotation_col = hgdp_tgp, annotation_colors = annot_reg_colr, fontsize_row = 5, fontsize_col= 5, angle_col = 90, border_color=NA, height=7, width=9, color = brewer.pal(9,"Blues"), na_col="white", show_colnames = F, treeheight_row=0)
# read-in table with doubleton counts
ds <- read.csv(file = '~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/doubleton_count.csv', sep = "\t") # 5707131 rows × 3 columns
# exclude rows where a sample is set against itself
ds_not <- ds[!(ds$sample1 == ds$sample2), ]
# sanity check
dim(ds)[1] - 3378 == dim(ds_not)[1] # TRUE
# reverse columns and rename col names
reverse_ds <- ds_not[c("sample2", "sample1", "count")]
names(reverse_ds) <- names(ds_not)
# join original and reversed tables together
joined_ds <- rbind(ds_not,reverse_ds)
# set up final table
final_ds <- rbind(ds[(ds$sample1 == ds$sample2), ], joined_ds)
# sanity check
dim(final_ds)[1] == dim(joined_ds)[1] + 3378 # TRUE
# cast final table (3378 by 3379 - the extra one column is the sample IDs)
cor_mat <- dcast(final_ds, sample1~sample2, value.var='count')
# update row names with sample IDs
rownames(cor_mat) <- cor_mat[,1]
# remove the sample ID column and convert data frame into a correlation matrix (3380 by 3380)
cor_mat <- as.matrix(cor_mat[-1])
# make a heatmap - takes a bit time to run
#pheatmap(cor_mat)
# read-in metadata from gnomAD and select only the desired columns
hgdp_tgp_unfil <- read.delim('~/Desktop/Broad/alicia/HGDP_TGP/hgdp_tgp/gnomad_meta_v1.tsv', header=T, sep='\t') %>% select(s, project_meta.title, starts_with('hgdp_tgp_meta'))
# some sample IDs have 'v3.1::' prefix as done in gnomAD so stripping that in order to match correctly with the pc score files
hgdp_tgp_unfil$s <- gsub('v3.1::', '', hgdp_tgp_unfil$s)
# set up df for annotation
hgdp_tgp <- hgdp_tgp_unfil[hgdp_tgp_unfil$s %in% unique(ds$sample1),] # subset metadata to only samples with doubletons
hgdp_tgp <- hgdp_tgp[c("s", "hgdp_tgp_meta.Population", "hgdp_tgp_meta.Genetic.region")] # select only sample ID, population and region columns
rownames(hgdp_tgp) <- hgdp_tgp[,1] # set sample IDs as rownames
hgdp_tgp <- hgdp_tgp[-1] # remove the sample ID column
colnames(hgdp_tgp) <- c("Population", "Region") # rename columns
hgdp_tgp_reg <- within(hgdp_tgp, rm(Population)) # only keep the region column
hgdp_tgp_pop <- within(hgdp_tgp, rm(Region)) # only keep the population column
### set color for heat map annotation - obtain from metadata itself for consistency across all plots
# region
reg_colr_df <- unique(hgdp_tgp_unfil[c("hgdp_tgp_meta.Genetic.region", "hgdp_tgp_meta.Continent.colors")])
reg_colr <- reg_colr_df %>% pull(hgdp_tgp_meta.Continent.colors, hgdp_tgp_meta.Genetic.region)
#annot_reg_colr <- list(Region = reg_colr) # convert into a list
# population within each region
pop_colr_df <- unique(hgdp_tgp_unfil[c("hgdp_tgp_meta.Population", "hgdp_tgp_meta.Pop.colors")])
pop_colr <- pop_colr_df %>% pull(hgdp_tgp_meta.Pop.colors, hgdp_tgp_meta.Population)
annot_colr <- list(Region = reg_colr, Population = pop_colr) # convert into a list
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
rnames <- rownames(mat_log)
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
mat_log <- log10(cor_mat+1)
knitr::opts_chunk$set(echo = TRUE)
library(pheatmap)
library(grid)
library(reshape2)
library(dplyr)
# read-in table with doubleton counts
ds <- read.csv(file = '~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/doubleton_count.csv', sep = "\t") # 5707131 rows × 3 columns
# exclude rows where a sample is set against itself
ds_not <- ds[!(ds$sample1 == ds$sample2), ]
# sanity check
dim(ds)[1] - 3378 == dim(ds_not)[1] # TRUE
# reverse columns and rename col names
reverse_ds <- ds_not[c("sample2", "sample1", "count")]
names(reverse_ds) <- names(ds_not)
# join original and reversed tables together
joined_ds <- rbind(ds_not,reverse_ds)
# set up final table
final_ds <- rbind(ds[(ds$sample1 == ds$sample2), ], joined_ds)
# sanity check
dim(final_ds)[1] == dim(joined_ds)[1] + 3378 # TRUE
# cast final table (3378 by 3379 - the extra one column is the sample IDs)
cor_mat <- dcast(final_ds, sample1~sample2, value.var='count')
# update row names with sample IDs
rownames(cor_mat) <- cor_mat[,1]
# remove the sample ID column and convert data frame into a correlation matrix (3380 by 3380)
cor_mat <- as.matrix(cor_mat[-1])
# make a heatmap - takes a bit time to run
#pheatmap(cor_mat)
# read-in metadata from gnomAD and select only the desired columns
hgdp_tgp_unfil <- read.delim('~/Desktop/Broad/alicia/HGDP_TGP/hgdp_tgp/gnomad_meta_v1.tsv', header=T, sep='\t') %>% select(s, project_meta.title, starts_with('hgdp_tgp_meta'))
# some sample IDs have 'v3.1::' prefix as done in gnomAD so stripping that in order to match correctly with the pc score files
hgdp_tgp_unfil$s <- gsub('v3.1::', '', hgdp_tgp_unfil$s)
# set up df for annotation
hgdp_tgp <- hgdp_tgp_unfil[hgdp_tgp_unfil$s %in% unique(ds$sample1),] # subset metadata to only samples with doubletons
hgdp_tgp <- hgdp_tgp[c("s", "hgdp_tgp_meta.Population", "hgdp_tgp_meta.Genetic.region")] # select only sample ID, population and region columns
rownames(hgdp_tgp) <- hgdp_tgp[,1] # set sample IDs as rownames
hgdp_tgp <- hgdp_tgp[-1] # remove the sample ID column
colnames(hgdp_tgp) <- c("Population", "Region") # rename columns
hgdp_tgp_reg <- within(hgdp_tgp, rm(Population)) # only keep the region column
hgdp_tgp_pop <- within(hgdp_tgp, rm(Region)) # only keep the population column
### set color for heat map annotation - obtain from metadata itself for consistency across all plots
# region
reg_colr_df <- unique(hgdp_tgp_unfil[c("hgdp_tgp_meta.Genetic.region", "hgdp_tgp_meta.Continent.colors")])
reg_colr <- reg_colr_df %>% pull(hgdp_tgp_meta.Continent.colors, hgdp_tgp_meta.Genetic.region)
#annot_reg_colr <- list(Region = reg_colr) # convert into a list
# population within each region
pop_colr_df <- unique(hgdp_tgp_unfil[c("hgdp_tgp_meta.Population", "hgdp_tgp_meta.Pop.colors")])
pop_colr <- pop_colr_df %>% pull(hgdp_tgp_meta.Pop.colors, hgdp_tgp_meta.Population)
annot_colr <- list(Region = reg_colr, Population = pop_colr) # convert into a list
# order the rows and columns of the correlation matrix according to the clustering from the heatmap and set the lower triangle to NA values (keeping the original dendogram)
mat_log <- log10(cor_mat+1)
rnames <- rownames(mat_log)
hc <-  hclust(dist(mat_log))
mat_log2 <- mat_log[hc$order, hc$order]
mat_log2[lower.tri(mat_log2)] <- NA
mat_log2 <- mat_log2[rnames, rnames]
make_space <-vector(mode="character", length = length(rownames(mat_log2))) # used to make space between plot and legend
legn_range <- head(seq(0, max(mat_log2, na.rm = T), .5), -1) # legend range
png(file="~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/fst_heatmap_uppertri.png", width = 9, height = 9, units = 'in', res = 300) # save heatmap as png
setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=.9, height=.9, name="vp", just=c("right","top"))), action="prepend")
pheatmap(mat_log2, cluster_col = hc, cluster_row = hc, annotation_row = hgdp_tgp_pop, annotation_col = hgdp_tgp_reg, angle_col = 90, annotation_legend = F, annotation_colors = annot_colr, border_color=NA, treeheight_row=0,height=7, width=9, show_rownames = T, show_colnames = F, legend_breaks = c(legn_range, max(mat_log)), legend_labels = round(c((10^legn_range)-1, (10^(max(mat_log)))-1), 0), labels_row = make_space, na_col="white")
setHook("grid.newpage", NULL, "replace")
grid.text("Samples", x = 0.45, y=0.08, gp=gpar(fontsize=13)) # xlabel
grid.text("Samples", x=-0.02, rot=90, gp=gpar(fontsize=13)) # ylabel
dev.off() # close file
knitr::opts_chunk$set(echo = TRUE)
library(pheatmap)
library(dplyr)
library(RColorBrewer)
library(geosphere)
library(ggplot2)
library(dendextend)
library(tibble)
# read-in metadata with longitude and latitude coordinates for each population
meta_ds <- read.delim('~/Desktop/Broad/alicia/HGDP_TGP/hgdp_tgp/gnomad_meta_v1.tsv', header=T, sep='\t')
View(meta_ds)
meta_ds$s <- gsub('v3.1::', '', meta_ds$s)
View(meta_ds)
# read-in metadata with longitude and latitude coordinates for each population
meta_ds <- read.delim('~/Desktop/Broad/alicia/HGDP_TGP/hgdp_tgp/gnomad_meta_v1.tsv', header=T, sep='\t') %>% select(s, project_meta.title, starts_with('hgdp_tgp_meta'))
meta_ds$s <- gsub('v3.1::', '', meta_ds$s)
View(meta_ds)
relateds <- read.delim('~/Downloads/related_ids.tsv', header=T, sep='\t')
View(relateds)
relateds$node <- gsub('{s:', '', relateds$node)
relateds$node <- gsub('s:', '', relateds$node)
gsub("\\{|\\}", "", relateds$node)
relateds$node <- gsub("\\{|\\}", "", relateds$node)
colnames(relateds) <- "s"
write.table(relateds, file='~/Downloads/relateds.txt')
write.table(relateds, file='~/Downloads/relateds.txt', row.names = F)
View(relateds)
meta_ds <- read.delim('~/Desktop/Broad/alicia/HGDP_TGP/hgdp_tgp/gnomad_meta_v1.tsv', header=T, sep='\t') %>% select(s, project_meta.title, hgdp_tgp_meta.Population, hgdp_tgp_meta.Genetic.region)
meta_ds$s <- gsub('v3.1::', '', meta_ds$s)
View(meta_ds)
meta_ds$relatedness_info <- ifelse(meta_ds$s %in% relateds$s, "related", "unrelated")
View(meta_ds)
View(relateds)
table(meta_ds$relatedness_info)
View(meta_ds)
colnames(meta_ds) <- c("s", "project", "population", "genetic region", "relatedness info")
View(meta_ds)
write.table(meta_ds, file="~/Downloads/all_samples.tsv", sep="\t")
write.table(meta_ds, file="~/Downloads/all_samples.tsv", sep="\t", row.names = F)
View(meta_ds)
knitr::opts_chunk$set(echo = TRUE)
library(pheatmap)
library(dplyr)
library(RColorBrewer)
library(geosphere)
library(ggplot2)
library(dendextend)
library(tibble)
# read-in file with fst values
fst_tbl <- read.table('~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/mean_fst.txt')
# make the column names consistent across the two data sets
colnames(fst_tbl) <- c("Pop1","Pop2", "F_ST")
# only keep the pairs that are found in the mean fst table
#pop_pairs_fst = inner_join(all_pop_pairs, fst_tbl, by = c("Var1" = "Pop1", "Var2" = "Pop2"))
# read-in metadata with longitude and latitude coordinates for each population
hgdp_tgp_coor <- read.delim('~/Desktop/Broad/alicia/HGDP_TGP/hgdp_tgp/gnomad_meta_v1.tsv', header=T, sep='\t') %>% select(hgdp_tgp_meta.Population, hgdp_tgp_meta.Genetic.region, hgdp_tgp_meta.Latitude, hgdp_tgp_meta.Longitude, project_meta.title)
# since the samples within each population have the same coordinates, only keep one for each
hgdp_tgp_coor <- unique(hgdp_tgp_coor)
# join the metadata table with the fst one using population names
# so for both populations, we will have the coordinates, genetic region and which project they came from
merged_tbl <-  left_join(fst_tbl, hgdp_tgp_coor, by=c("Pop1" = "hgdp_tgp_meta.Population")) %>% left_join(hgdp_tgp_coor, by=c("Pop2" = "hgdp_tgp_meta.Population")) %>% rename(GR1 = hgdp_tgp_meta.Genetic.region.x, Lat1 = hgdp_tgp_meta.Latitude.x, Long1 = hgdp_tgp_meta.Longitude.x, Project1 = project_meta.title.x, GR2 = hgdp_tgp_meta.Genetic.region.y, Lat2 = hgdp_tgp_meta.Latitude.y, Long2 = hgdp_tgp_meta.Longitude.y, Project2 = project_meta.title.y)
## what are each columns in the merged table?
# col 1 = pop1 name
# col 2 = pop2 name
# col 3 = mean F_ST
# col 4 = pop1 genetic region
# col 5 =  pop1 latitudinal coordinate
# col 6 = pop1 longitudinal coordinate
# col 7 = pop1 project
# col 8 = pop2 genetic region
# col 9 =  pop2 latitudinal coordinate
# col 10 = pop2 longitudinal coordinate
# col 11 = pop2 project
# read-in file with fst values
fst_tbl <- read.table('~/Desktop/Broad/alicia/HGDP_TGP/fst_and_f2/mean_fst.txt')
# make the column names consistent across the two data sets
colnames(fst_tbl) <- c("Pop1","Pop2", "F_ST")
# only keep the pairs that are found in the mean fst table
#pop_pairs_fst = inner_join(all_pop_pairs, fst_tbl, by = c("Var1" = "Pop1", "Var2" = "Pop2"))
# read-in metadata with longitude and latitude coordinates for each population
hgdp_tgp_coor <- read.delim('~/Desktop/Broad/alicia/HGDP_TGP/hgdp_tgp/gnomad_meta_v1.tsv', header=T, sep='\t') %>% select(hgdp_tgp_meta.Population, hgdp_tgp_meta.Genetic.region, hgdp_tgp_meta.Latitude, hgdp_tgp_meta.Longitude, project_meta.title)
# since the samples within each population have the same coordinates, only keep one for each
hgdp_tgp_coor <- unique(hgdp_tgp_coor)
# join the metadata table with the fst one using population names
# so for both populations, we will have the coordinates, genetic region and which project they came from
merged_tbl <-  left_join(fst_tbl, hgdp_tgp_coor, by=c("Pop1" = "hgdp_tgp_meta.Population")) %>% left_join(hgdp_tgp_coor, by=c("Pop2" = "hgdp_tgp_meta.Population")) %>% rename(GR1 = hgdp_tgp_meta.Genetic.region.x, Lat1 = hgdp_tgp_meta.Latitude.x, Long1 = hgdp_tgp_meta.Longitude.x, Project1 = project_meta.title.x, GR2 = hgdp_tgp_meta.Genetic.region.y, Lat2 = hgdp_tgp_meta.Latitude.y, Long2 = hgdp_tgp_meta.Longitude.y, Project2 = project_meta.title.y)
## what are each columns in the merged table?
# col 1 = pop1 name
# col 2 = pop2 name
# col 3 = mean F_ST
# col 4 = pop1 genetic region
# col 5 =  pop1 latitudinal coordinate
# col 6 = pop1 longitudinal coordinate
# col 7 = pop1 project
# col 8 = pop2 genetic region
# col 9 =  pop2 latitudinal coordinate
# col 10 = pop2 longitudinal coordinate
# col 11 = pop2 project
# create a data frame of all waypoints
istanbul <- c(41,28) # city in Turkey
cairo <- c(30,31) # capital of Egypt
phnom.penh <- c(11,104) # capital of Cambodia
anadyr <- c(64,177) # town in Russia
prince.rupert <- c(54,-130) # city in British Columbia, Canada - actual longitude value is negative but for this particular calculation, we made it positive because we wanted the distance paths to be uniform (when we calculate distance between ACB (AFR population) and the 5 waypoints, the shortest distance is to prince.rupert so if we wanted to calculate the distance between ACB and a EUR population, the path of calculation would be ACB -> prince.rupert -> EUR popultion which is not the right path we want to take. The correct one is ACB -> cairo -> istanbul -> EUR popualtion).
waypoints <- as.data.frame(rbind(istanbul, cairo, phnom.penh, anadyr, prince.rupert), stringsAsFactors = FALSE) # create a df
waypoints <- waypoints %>% rownames_to_column("City") %>% rename(Lat=V1, Long=V2) # rename col names
# using 6371 km or 3961 miles for the earth's radius
# number of rows in merged table - 3003 population pairs
n_rows = dim(merged_tbl)[1]
# create an empty matrix with 9 columns to hold final result
final_mat <- array(0, dim=c(n_rows,9))
colnames(final_mat) <- c("Pop1", "GR1", "Project1", "Pop2", "GR2", "Project2", "Mean.F_ST", "Distance", "Path")
# for each population pair, run the following:
for(i in 1:n_rows){
Pop1 = merged_tbl[i, 1] # get the first population in the pair
Pop2 = merged_tbl[i, 2] # get the first population in the pair
# variables for keeping track of values when calculating distance between two populations
AMIThereYet = FALSE
TotalDistance = 0
MyPath = Pop1 # set the starting location - Pop1
while (AMIThereYet == FALSE){
# which city is the closest to Pop1 (compare the distances between Pop1 and all way points)?
pop1_waypoints <- distHaversine(merged_tbl[i, 6:5], waypoints[, 3:2], r=6371)
shortest_index_pop1 <- which.min(pop1_waypoints) # get index of the waypoint that is closest to Pop1
shortest_pop1_waypoint <- pop1_waypoints[shortest_index_pop1]
waypoint1 <- waypoints[shortest_index_pop1, "City"] # closest waypoint to Pop1
# calculate the distance between Pop1 and Pop2
pop1_pop2 <- distHaversine(merged_tbl[i, 6:5], merged_tbl[i, 10:9], r=6371)
# if the distance between Pop1 and the closest waypoint (waypoint1) is less than the distance between Pop1 and Pop2, go through waypoint1
if(shortest_pop1_waypoint < pop1_pop2) { # 1st if statement
TotalDistance = TotalDistance + shortest_pop1_waypoint # add the shortest distance to the total distance
MyPath = paste(MyPath, waypoint1, sep=" -> ") # to keep track of the path we are taking
# from the other 4 waypoints, which one is the closest to waypoint1?
waypoints_wo_waypoint1 <- filter(waypoints, City != waypoint1) # subset the waypoints df
waypoint1_otherwaypoints <- distHaversine(waypoints[shortest_index_pop1, 3:2], waypoints_wo_waypoint1[, 3:2], r=6371) # distance between waypoint1 and the other 4 waypoints
shortest_index_waypoint1 <- which.min(waypoint1_otherwaypoints) # get index of the waypoint that is closest to waypoint1
shortest_waypoint1_otherwaypoints <- waypoint1_otherwaypoints[shortest_index_waypoint1]
waypoint2 <- waypoints_wo_waypoint1[shortest_index_waypoint1, "City"] # second closest waypoint to Pop1
# calculate the distance between waypoint1 and Pop2
waypoint1_pop2 <- distHaversine(waypoints[shortest_index_pop1, 3:2], merged_tbl[i, 10:9], r=6371)
# if the distance between waypoint1 and waypoint2 is less than the distance between waypoint1 and Pop2, go through waypoint2
if(shortest_waypoint1_otherwaypoints < waypoint1_pop2) { # 2nd if statement
TotalDistance = TotalDistance + shortest_waypoint1_otherwaypoints # add the shortest distance to the total distance
MyPath = paste(MyPath, waypoint2, sep=" -> ") # to keep track of the path we are taking
# from the other 3 waypoints, which one is the closest to waypoint2?
waypoints_wo_waypoint2 <- filter(waypoints_wo_waypoint1, City != waypoint2) # subset the waypoints df further
waypoint2_otherwaypoints <- distHaversine(waypoints[shortest_index_waypoint1, 3:2], waypoints_wo_waypoint2[, 3:2], r=6371) # distance between waypoint2 and the other 3 waypoints
shortest_index_waypoint2 <- which.min(waypoint2_otherwaypoints) # get index of the waypoint that is closest to waypoint2
shortest_waypoint2_otherwaypoints <- waypoint2_otherwaypoints[shortest_index_waypoint2]
waypoint3 <- waypoints_wo_waypoint2[shortest_index_waypoint2, "City"] # third closest waypoint to Pop1
# calculate the distance between waypoint2 and Pop2
waypoint2_pop2 <- distHaversine(waypoints_wo_waypoint1[shortest_index_waypoint1, 3:2], merged_tbl[i, 10:9], r=6371)
# if the distance between waypoint2 and waypoint3 is less than the distance between waypoint2 and Pop2, go through waypoint3
if(shortest_waypoint2_otherwaypoints < waypoint2_pop2) { # 3rd if statement
TotalDistance = TotalDistance + shortest_waypoint2_otherwaypoints # add the shortest distance to the total distance
MyPath = paste(MyPath, waypoint3, sep=" -> ") # to keep track of the path we are taking
# from the last 2 waypoints, which one is the closest to waypoint3?
waypoints_wo_waypoint3 <- filter(waypoints_wo_waypoint2, City != waypoint3) # subset the waypoints df
waypoint3_otherwaypoints <- distHaversine(waypoints[shortest_index_waypoint2, 3:2], waypoints_wo_waypoint3[, 3:2], r=6371) # distance between waypoint3 and the last 2 waypoints
shortest_index_waypoint3 <- which.min(waypoint3_otherwaypoints) # get index of the waypoint that is closest to waypoint3
shortest_waypoint3_otherwaypoints <- waypoint3_otherwaypoints[shortest_index_waypoint3]
waypoint4 <- waypoints_wo_waypoint3[shortest_index_waypoint3, "City"] # fourth closest waypoint to Pop1
# calculate the distance between waypoint3 and Pop2
waypoint3_pop2 <- distHaversine(waypoints_wo_waypoint2[shortest_index_waypoint2, 3:2], merged_tbl[i, 10:9], r=6371)
# if the distance between waypoint3 and waypoint4 is less than the distance between waypoint3 and Pop2, go through waypoint4
if(shortest_waypoint3_otherwaypoints < waypoint3_pop2) { # 4th if statement
TotalDistance = TotalDistance + shortest_waypoint3_otherwaypoints # add the shortest distance to the total distance
MyPath = paste(MyPath, waypoint4, sep=" -> ") # to keep track of the path we are taking
# calculate the distance between waypoint4 and the last waypoint
waypoints_wo_waypoint4 <- filter(waypoints_wo_waypoint3, City != waypoint4) # subset the waypoints df to the last waypoint (one row left)
waypoint4_lastwaypoint <- distHaversine(waypoints[shortest_index_waypoint3, 3:2], waypoints_wo_waypoint4[, 3:2], r=6371) # distance between waypoint4 and the last waypoint
shortest_index_waypoint4 <- which.min(waypoint4_lastwaypoint) # index of the last waypoint that is closest to waypoint4
shortest_waypoint4_lastwaypoint <- waypoint4_lastwaypoint[shortest_index_waypoint4]
waypoint5 <- waypoints_wo_waypoint4[shortest_index_waypoint4, "City"] # last closest waypoint to Pop1
# calculate the distance between waypoint4 and Pop2
waypoint4_pop2 <- distHaversine(waypoints_wo_waypoint3[shortest_index_waypoint3, 3:2], merged_tbl[i, 10:9], r=6371)
# if the distance between waypoint4 and the last waypoint (waypoint5) is less than the distance between waypoint4 and Pop2, go through the last waypoint
if(shortest_waypoint4_lastwaypoint < waypoint4_pop2) { # 5th if statement
TotalDistance = TotalDistance + shortest_waypoint4_lastwaypoint # add the shortest distance to the total distance
MyPath = paste(MyPath, waypoint5, sep=" -> ") # to keep track of the path we are taking
# calculate the distance between the last waypoint and Pop2
lastwaypoint_pop2 <- distHaversine(waypoints_wo_waypoint4[, 3:2], merged_tbl[i, 10:9], r=6371)
waypoint5 <- waypoints_wo_waypoint4$City # last waypoint
TotalDistance = TotalDistance + lastwaypoint_pop2 # add the distance between the last waypoint and Pop2 to the total distance
MyPath = paste(MyPath, waypoint5, sep=" -> ") # to keep track of the path we are taking
AMIThereYet = TRUE
# if the distance between waypoint4 and Pop2 is less than the distance between waypoint4 and the last waypoint (waypoint5), go straight to Pop2
} else { # close 5th if statement
TotalDistance = TotalDistance + waypoint4_pop2 # add the shortest distance to the total distance
MyPath = paste(MyPath, Pop2, sep=" -> ") # to keep track of the path we are taking
AMIThereYet = TRUE
}
# if the distance between waypoint3 and Pop2 is less than the distance between waypoint3 and waypoint4, go through waypoint4
} else { # close 4th if statement
TotalDistance = TotalDistance + waypoint3_pop2 # add the shortest distance to the total distance
MyPath = paste(MyPath, Pop2, sep=" -> ") # to keep track of the path we are taking
AMIThereYet = TRUE
}
# if the distance between waypoint2 and Pop2 is less than the distance between waypoint2 and waypoint3, go straight to Pop2
} else { # close 3rd if statement
TotalDistance = TotalDistance + waypoint2_pop2 # add the shortest distance to the total distance
MyPath = paste(MyPath, Pop2, sep=" -> ") # to keep track of the path we are taking
AMIThereYet = TRUE
}
# if the distance between waypoint1 and Pop2 is less than the distance between waypoint1 and waypoint2, go straight to Pop2
} else { # close 2nd if statement
TotalDistance = TotalDistance + waypoint1_pop2 # add the shortest distance to the total distance
MyPath = paste(MyPath, Pop2, sep=" -> ") # to keep track of the path we are taking
AMIThereYet = TRUE
}
# if the distance between Pop1 and Pop2 is less than the distance between Pop1 and waypoint1, go straight to Pop2
} else { # close 1st if statement
TotalDistance = TotalDistance + pop1_pop2 # add the shortest distance to the total distance
MyPath = paste(MyPath, Pop2, sep=" -> ") # to keep track of the path we are taking
AMIThereYet = TRUE
}
} # close the while loop
# add the final results and other additional information (from the original merged table) to the final matrix
final_mat[i,1] = Pop1
final_mat[i,2] = merged_tbl[i, 4] # GR for Pop1
final_mat[i,3] = merged_tbl[i, 7] # project Pop1 came from
final_mat[i,4] = Pop2
final_mat[i,5] = merged_tbl[i, 8] # GR for Pop2
final_mat[i,6] = merged_tbl[i,11] # project Pop2 came from
final_mat[i,7] = merged_tbl[i,3] # mean F_ST between the population pair
final_mat[i,8] = TotalDistance # calculated total distance between the population pair
final_mat[i,9] = MyPath # path that was taken when calculating distance (through which waypoints?)
} # close the for loop
View(final_mat)
